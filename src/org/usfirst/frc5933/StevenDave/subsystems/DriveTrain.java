// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc5933.StevenDave.subsystems;

import org.usfirst.frc5933.StevenDave.RobotMap;
import org.usfirst.frc5933.StevenDave.commands.*;

import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.CANTalon;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.Joystick;

import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class DriveTrain extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final CANTalon frontLeftMotor = RobotMap.driveTrainFrontLeftMotor;
    private final CANTalon frontRightMotor = RobotMap.driveTrainFrontRightMotor;
    private final RobotDrive robotDrive = RobotMap.driveTrainRobotDrive;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public static final int TURN_MAX_TRIES = 1000;

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    public void readUltrasonic(){
    }

    public void arcadeDrive(Joystick stick) {
    	robotDrive.arcadeDrive(stick);
    }
    
    public void stop(){
    	robotDrive.stopMotor();
    }

    public void enableBrakeMode(boolean enable) {
        frontLeftMotor.enableBrakeMode(enable);
        frontRightMotor.enableBrakeMode(enable);
    }

    public void driveStraight(double speed, double curve) {
        robotDrive.drive(speed, curve);
    }
    public void turnDegrees(double speed, double degrees) {
        enableBrakeMode(true);
        RobotMap.helmsman.resetGyro();
        final double startingAngle = RobotMap.helmsman.getCurrentGyroAngle();
        double now = startingAngle;
        final double desired = now + degrees;

        int tries = TURN_MAX_TRIES;

        if (desired > startingAngle) {
            do {
                robotDrive.tankDrive(-speed, speed);
                now = RobotMap.helmsman.getCurrentGyroAngle();
                --tries;
                if (tries == 0) {
                    System.err.println("Failed to turn specified degrees.");
                    break;
                }
            } while (now < desired);
        } else {
            do {
                robotDrive.tankDrive(speed, -speed);
                now = RobotMap.helmsman.getCurrentGyroAngle();
                --tries;
                if (tries == 0) {
                    System.err.println("Failed to turn specified degrees.");
                    break;
                }
            } while (now > startingAngle + degrees);
        }
        enableBrakeMode(false);

        stop();
    }
}

